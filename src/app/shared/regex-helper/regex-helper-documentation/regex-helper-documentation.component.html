<div class="section" id="regular-expression-syntax">
    <span id="re-syntax"></span><h2>Regular Expression Syntax<a class="headerlink" title="Permalink to this headline"></a></h2>
    <p>A regular expression (or RE) specifies a set of strings that matches it; the
    functions in this module let you check if a particular string matches a given
    regular expression (or if a given regular expression matches a particular
    string, which comes down to the same thing).</p>
    <p>Regular expressions can be concatenated to form new regular expressions; if <em>A</em>
    and <em>B</em> are both regular expressions, then <em>AB</em> is also a regular expression.
    In general, if a string <em>p</em> matches <em>A</em> and another string <em>q</em> matches <em>B</em>, the
    string <em>pq</em> will match AB.  This holds unless <em>A</em> or <em>B</em> contain low precedence
    operations; boundary conditions between <em>A</em> and <em>B</em>; or have numbered group
    references.  Thus, complex expressions can easily be constructed from simpler
    primitive expressions like the ones described here.</p>
    <p>Regular expressions can contain both special and ordinary characters. Most
    ordinary characters, like <code class="docutils literal notranslate"><span class="pre">'A'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'0'</span></code>, are the simplest regular
    expressions; they simply match themselves.  You can concatenate ordinary
    characters, so <code class="docutils literal notranslate"><span class="pre">last</span></code> matches the string <code class="docutils literal notranslate"><span class="pre">'last'</span></code>.  (In the rest of this
    section, we’ll write RE’s in <code class="docutils literal notranslate"><span class="pre">this</span> <span class="pre">special</span> <span class="pre">style</span></code>, usually without quotes, and
    strings to be matched <code class="docutils literal notranslate"><span class="pre">'in</span> <span class="pre">single</span> <span class="pre">quotes'</span></code>.)</p>
    <p>Some characters, like <code class="docutils literal notranslate"><span class="pre">'|'</span></code> or <code class="docutils literal notranslate"><span class="pre">'('</span></code>, are special. Special
    characters either stand for classes of ordinary characters, or affect
    how the regular expressions around them are interpreted.</p>
    <p>Repetition qualifiers (<code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">{{"{"}}m,n{{"}"}}</span></code>, etc) cannot be
    directly nested. This avoids ambiguity with the non-greedy modifier suffix
    <code class="docutils literal notranslate"><span class="pre">?</span></code>, and with other modifiers in other implementations. To apply a second
    repetition to an inner repetition, parentheses may be used. For example,
    the expression <code class="docutils literal notranslate"><span class="pre">(?:a{{"{"}}6{{"}"}})*</span></code> matches any multiple of six <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters.</p>
    <p>The special characters are:</p>
    <dl class="simple" id="index-0">
    <dt><code class="docutils literal notranslate"><span class="pre">.</span></code></dt><dd><p>(Dot.)  In the default mode, this matches any character except a newline.  If
    the <a class="reference internal" href="#re.DOTALL" title="re.DOTALL"><code class="xref py py-const docutils literal notranslate"><span class="pre">DOTALL</span></code></a> flag has been specified, this matches any character
    including a newline.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-1">
    <dt><code class="docutils literal notranslate"><span class="pre">^</span></code></dt><dd><p>(Caret.)  Matches the start of the string, and in <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> mode also
    matches immediately after each newline.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-2">
    <dt><code class="docutils literal notranslate"><span class="pre">$</span></code></dt><dd><p>Matches the end of the string or just before the newline at the end of the
    string, and in <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> mode also matches before a newline.  <code class="docutils literal notranslate"><span class="pre">foo</span></code>
    matches both ‘foo’ and ‘foobar’, while the regular expression <code class="docutils literal notranslate"><span class="pre">foo$</span></code> matches
    only ‘foo’.  More interestingly, searching for <code class="docutils literal notranslate"><span class="pre">foo.$</span></code> in <code class="docutils literal notranslate"><span class="pre">'foo1\nfoo2\n'</span></code>
    matches ‘foo2’ normally, but ‘foo1’ in <a class="reference internal" href="#re.MULTILINE" title="re.MULTILINE"><code class="xref py py-const docutils literal notranslate"><span class="pre">MULTILINE</span></code></a> mode; searching for
    a single <code class="docutils literal notranslate"><span class="pre">$</span></code> in <code class="docutils literal notranslate"><span class="pre">'foo\n'</span></code> will find two (empty) matches: one just before
    the newline, and one at the end of the string.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-3">
    <dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt><dd><p>Causes the resulting RE to match 0 or more repetitions of the preceding RE, as
    many repetitions as are possible.  <code class="docutils literal notranslate"><span class="pre">ab*</span></code> will match ‘a’, ‘ab’, or ‘a’ followed
    by any number of ‘b’s.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-4">
    <dt><code class="docutils literal notranslate"><span class="pre">+</span></code></dt><dd><p>Causes the resulting RE to match 1 or more repetitions of the preceding RE.
    <code class="docutils literal notranslate"><span class="pre">ab+</span></code> will match ‘a’ followed by any non-zero number of ‘b’s; it will not
    match just ‘a’.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-5">
    <dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt><dd><p>Causes the resulting RE to match 0 or 1 repetitions of the preceding RE.
    <code class="docutils literal notranslate"><span class="pre">ab?</span></code> will match either ‘a’ or ‘ab’.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-6">
    <dt><code class="docutils literal notranslate"><span class="pre">*?</span></code>, <code class="docutils literal notranslate"><span class="pre">+?</span></code>, <code class="docutils literal notranslate"><span class="pre">??</span></code></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'?'</span></code> qualifiers are all <em class="dfn">greedy</em>; they match
    as much text as possible.  Sometimes this behaviour isn’t desired; if the RE
    <code class="docutils literal notranslate"><span class="pre">&lt;.*&gt;</span></code> is matched against <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;</span> <span class="pre">b</span> <span class="pre">&lt;c&gt;'</span></code>, it will match the entire
    string, and not just <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.  Adding <code class="docutils literal notranslate"><span class="pre">?</span></code> after the qualifier makes it
    perform the match in <em class="dfn">non-greedy</em> or <em class="dfn">minimal</em> fashion; as <em>few</em>
    characters as possible will be matched.  Using the RE <code class="docutils literal notranslate"><span class="pre">&lt;.*?&gt;</span></code> will match
    only <code class="docutils literal notranslate"><span class="pre">'&lt;a&gt;'</span></code>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-7">
    <dt><code class="docutils literal notranslate"><span class="pre">{{"{"}}m{{"}"}}</span></code></dt><dd><p>Specifies that exactly <em>m</em> copies of the previous RE should be matched; fewer
    matches cause the entire RE not to match.  For example, <code class="docutils literal notranslate"><span class="pre">a{{"{"}}6{{"}"}}</span></code> will match
    exactly six <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters, but not five.</p>
    </dd>
    <dt><code class="docutils literal notranslate"><span class="pre">{{"{"}}m,n{{"}"}}</span></code></dt><dd><p>Causes the resulting RE to match from <em>m</em> to <em>n</em> repetitions of the preceding
    RE, attempting to match as many repetitions as possible.  For example,
    <code class="docutils literal notranslate"><span class="pre">a{{"{"}}3,5{{"}"}}</span></code> will match from 3 to 5 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters.  Omitting <em>m</em> specifies a
    lower bound of zero,  and omitting <em>n</em> specifies an infinite upper bound.  As an
    example, <code class="docutils literal notranslate"><span class="pre">a{{"{"}}4,{{"}"}}b</span></code> will match <code class="docutils literal notranslate"><span class="pre">'aaaab'</span></code> or a thousand <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters
    followed by a <code class="docutils literal notranslate"><span class="pre">'b'</span></code>, but not <code class="docutils literal notranslate"><span class="pre">'aaab'</span></code>. The comma may not be omitted or the
    modifier would be confused with the previously described form.</p>
    </dd>
    <dt><code class="docutils literal notranslate"><span class="pre">{{"{"}}m,n{{"}"}}?</span></code></dt><dd><p>Causes the resulting RE to match from <em>m</em> to <em>n</em> repetitions of the preceding
    RE, attempting to match as <em>few</em> repetitions as possible.  This is the
    non-greedy version of the previous qualifier.  For example, on the
    6-character string <code class="docutils literal notranslate"><span class="pre">'aaaaaa'</span></code>, <code class="docutils literal notranslate"><span class="pre">a{{"{"}}3,5{{"}"}}</span></code> will match 5 <code class="docutils literal notranslate"><span class="pre">'a'</span></code> characters,
    while <code class="docutils literal notranslate"><span class="pre">a{{"{"}}3,5{{"}"}}?</span></code> will only match 3 characters.</p>
    </dd>
    </dl>
    <dl id="index-8">
    <dt><code class="docutils literal notranslate"><span class="pre">\</span></code></dt><dd><p>Either escapes special characters (permitting you to match characters like
    <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, <code class="docutils literal notranslate"><span class="pre">'?'</span></code>, and so forth), or signals a special sequence; special
    sequences are discussed below.</p>
    <p>If you’re not using a raw string to express the pattern, remember that Python
    also uses the backslash as an escape sequence in string literals; if the escape
    sequence isn’t recognized by Python’s parser, the backslash and subsequent
    character are included in the resulting string.  However, if Python would
    recognize the resulting sequence, the backslash should be repeated twice.  This
    is complicated and hard to understand, so it’s highly recommended that you use
    raw strings for all but the simplest expressions.</p>
    </dd>
    </dl>
    <dl id="index-9">
    <dt><code class="docutils literal notranslate"><span class="pre">[]</span></code></dt><dd><p>Used to indicate a set of characters.  In a set:</p>
    <ul class="simple">
    <li><p>Characters can be listed individually, e.g. <code class="docutils literal notranslate"><span class="pre">[amk]</span></code> will match <code class="docutils literal notranslate"><span class="pre">'a'</span></code>,
    <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'k'</span></code>.</p></li>
    </ul>
    <ul class="simple" id="index-10">
    <li><p>Ranges of characters can be indicated by giving two characters and separating
    them by a <code class="docutils literal notranslate"><span class="pre">'-'</span></code>, for example <code class="docutils literal notranslate"><span class="pre">[a-z]</span></code> will match any lowercase ASCII letter,
    <code class="docutils literal notranslate"><span class="pre">[0-5][0-9]</span></code> will match all the two-digits numbers from <code class="docutils literal notranslate"><span class="pre">00</span></code> to <code class="docutils literal notranslate"><span class="pre">59</span></code>, and
    <code class="docutils literal notranslate"><span class="pre">[0-9A-Fa-f]</span></code> will match any hexadecimal digit.  If <code class="docutils literal notranslate"><span class="pre">-</span></code> is escaped (e.g.
    <code class="docutils literal notranslate"><span class="pre">[a\-z]</span></code>) or if it’s placed as the first or last character
    (e.g. <code class="docutils literal notranslate"><span class="pre">[-a]</span></code> or <code class="docutils literal notranslate"><span class="pre">[a-]</span></code>), it will match a literal <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.</p></li>
    <li><p>Special characters lose their special meaning inside sets.  For example,
    <code class="docutils literal notranslate"><span class="pre">[(+*)]</span></code> will match any of the literal characters <code class="docutils literal notranslate"><span class="pre">'('</span></code>, <code class="docutils literal notranslate"><span class="pre">'+'</span></code>,
    <code class="docutils literal notranslate"><span class="pre">'*'</span></code>, or <code class="docutils literal notranslate"><span class="pre">')'</span></code>.</p></li>
    </ul>
    <ul class="simple" id="index-11">
    <li><p>Character classes such as <code class="docutils literal notranslate"><span class="pre">\w</span></code> or <code class="docutils literal notranslate"><span class="pre">\S</span></code> (defined below) are also accepted
    inside a set, although the characters they match depends on whether
    <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> or <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> mode is in force.</p></li>
    </ul>
    <ul class="simple" id="index-12">
    <li><p>Characters that are not within a range can be matched by <em class="dfn">complementing</em>
    the set.  If the first character of the set is <code class="docutils literal notranslate"><span class="pre">'^'</span></code>, all the characters
    that are <em>not</em> in the set will be matched.  For example, <code class="docutils literal notranslate"><span class="pre">[^5]</span></code> will match
    any character except <code class="docutils literal notranslate"><span class="pre">'5'</span></code>, and <code class="docutils literal notranslate"><span class="pre">[^^]</span></code> will match any character except
    <code class="docutils literal notranslate"><span class="pre">'^'</span></code>.  <code class="docutils literal notranslate"><span class="pre">^</span></code> has no special meaning if it’s not the first character in
    the set.</p></li>
    <li><p>To match a literal <code class="docutils literal notranslate"><span class="pre">']'</span></code> inside a set, precede it with a backslash, or
    place it at the beginning of the set.  For example, both <code class="docutils literal notranslate"><span class="pre">[()[\]{{"{"}}{{"}"}}]</span></code> and
    <code class="docutils literal notranslate"><span class="pre">[]()[{{"{"}}{{"}"}}]</span></code> will both match a parenthesis.</p></li>
    </ul>
    <ul class="simple">
    <li><p>Support of nested sets and set operations as in <a class="reference external" href="https://unicode.org/reports/tr18/">Unicode Technical
    Standard #18</a> might be added in the future.  This would change the
    syntax, so to facilitate this change a <a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> will be raised
    in ambiguous cases for the time being.
    That includes sets starting with a literal <code class="docutils literal notranslate"><span class="pre">'['</span></code> or containing literal
    character sequences <code class="docutils literal notranslate"><span class="pre">'--'</span></code>, <code class="docutils literal notranslate"><span class="pre">'&amp;&amp;'</span></code>, <code class="docutils literal notranslate"><span class="pre">'~~'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'||'</span></code>.  To
    avoid a warning escape them with a backslash.</p></li>
    </ul>
    <div class="versionchanged">
    <p><span class="versionmodified changed">Changed in version 3.7: </span><a class="reference internal" href="exceptions.html#FutureWarning" title="FutureWarning"><code class="xref py py-exc docutils literal notranslate"><span class="pre">FutureWarning</span></code></a> is raised if a character set contains constructs
    that will change semantically in the future.</p>
    </div>
    </dd>
    </dl>
    <dl class="simple" id="index-13">
    <dt><code class="docutils literal notranslate"><span class="pre">|</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">A|B</span></code>, where <em>A</em> and <em>B</em> can be arbitrary REs, creates a regular expression that
    will match either <em>A</em> or <em>B</em>.  An arbitrary number of REs can be separated by the
    <code class="docutils literal notranslate"><span class="pre">'|'</span></code> in this way.  This can be used inside groups (see below) as well.  As
    the target string is scanned, REs separated by <code class="docutils literal notranslate"><span class="pre">'|'</span></code> are tried from left to
    right. When one pattern completely matches, that branch is accepted. This means
    that once <em>A</em> matches, <em>B</em> will not be tested further, even if it would
    produce a longer overall match.  In other words, the <code class="docutils literal notranslate"><span class="pre">'|'</span></code> operator is never
    greedy.  To match a literal <code class="docutils literal notranslate"><span class="pre">'|'</span></code>, use <code class="docutils literal notranslate"><span class="pre">\|</span></code>, or enclose it inside a
    character class, as in <code class="docutils literal notranslate"><span class="pre">[|]</span></code>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-14">
    <dt><code class="docutils literal notranslate"><span class="pre">(...)</span></code></dt><dd><p>Matches whatever regular expression is inside the parentheses, and indicates the
    start and end of a group; the contents of a group can be retrieved after a match
    has been performed, and can be matched later in the string with the <code class="docutils literal notranslate"><span class="pre">\number</span></code>
    special sequence, described below.  To match the literals <code class="docutils literal notranslate"><span class="pre">'('</span></code> or <code class="docutils literal notranslate"><span class="pre">')'</span></code>,
    use <code class="docutils literal notranslate"><span class="pre">\(</span></code> or <code class="docutils literal notranslate"><span class="pre">\)</span></code>, or enclose them inside a character class: <code class="docutils literal notranslate"><span class="pre">[(]</span></code>, <code class="docutils literal notranslate"><span class="pre">[)]</span></code>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-15">
    <dt><code class="docutils literal notranslate"><span class="pre">(?...)</span></code></dt><dd><p>This is an extension notation (a <code class="docutils literal notranslate"><span class="pre">'?'</span></code> following a <code class="docutils literal notranslate"><span class="pre">'('</span></code> is not meaningful
    otherwise).  The first character after the <code class="docutils literal notranslate"><span class="pre">'?'</span></code> determines what the meaning
    and further syntax of the construct is. Extensions usually do not create a new
    group; <code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code> is the only exception to this rule. Following are the
    currently supported extensions.</p>
    </dd>
    <dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux)</span></code></dt><dd><p>(One or more letters from the set <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>,
    <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)  The group matches the empty string; the
    letters set the corresponding flags: <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII-only matching),
    <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignore case), <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (locale dependent),
    <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-line), <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (dot matches all),
    <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (Unicode matching), and <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbose),
    for the entire regular expression.
    (The flags are described in <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Module Contents</span></a>.)
    This is useful if you wish to include the flags as part of the
    regular expression, instead of passing a <em>flag</em> argument to the
    <a class="reference internal" href="#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a> function.  Flags should be used first in the
    expression string.</p>
    </dd>
    </dl>
    <dl id="index-16">
    <dt><code class="docutils literal notranslate"><span class="pre">(?:...)</span></code></dt><dd><p>A non-capturing version of regular parentheses.  Matches whatever regular
    expression is inside the parentheses, but the substring matched by the group
    <em>cannot</em> be retrieved after performing a match or referenced later in the
    pattern.</p>
    </dd>
    <dt><code class="docutils literal notranslate"><span class="pre">(?aiLmsux-imsx:...)</span></code></dt><dd><p>(Zero or more letters from the set <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>,
    <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>, optionally followed by <code class="docutils literal notranslate"><span class="pre">'-'</span></code> followed by
    one or more letters from the <code class="docutils literal notranslate"><span class="pre">'i'</span></code>, <code class="docutils literal notranslate"><span class="pre">'m'</span></code>, <code class="docutils literal notranslate"><span class="pre">'s'</span></code>, <code class="docutils literal notranslate"><span class="pre">'x'</span></code>.)
    The letters set or remove the corresponding flags:
    <a class="reference internal" href="#re.A" title="re.A"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.A</span></code></a> (ASCII-only matching), <a class="reference internal" href="#re.I" title="re.I"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.I</span></code></a> (ignore case),
    <a class="reference internal" href="#re.L" title="re.L"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.L</span></code></a> (locale dependent), <a class="reference internal" href="#re.M" title="re.M"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.M</span></code></a> (multi-line),
    <a class="reference internal" href="#re.S" title="re.S"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.S</span></code></a> (dot matches all), <code class="xref py py-const docutils literal notranslate"><span class="pre">re.U</span></code> (Unicode matching),
    and <a class="reference internal" href="#re.X" title="re.X"><code class="xref py py-const docutils literal notranslate"><span class="pre">re.X</span></code></a> (verbose), for the part of the expression.
    (The flags are described in <a class="reference internal" href="#contents-of-module-re"><span class="std std-ref">Module Contents</span></a>.)</p>
    <p>The letters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> and <code class="docutils literal notranslate"><span class="pre">'u'</span></code> are mutually exclusive when used
    as inline flags, so they can’t be combined or follow <code class="docutils literal notranslate"><span class="pre">'-'</span></code>.  Instead,
    when one of them appears in an inline group, it overrides the matching mode
    in the enclosing group.  In Unicode patterns <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> switches to
    ASCII-only matching, and <code class="docutils literal notranslate"><span class="pre">(?u:...)</span></code> switches to Unicode matching
    (default).  In byte pattern <code class="docutils literal notranslate"><span class="pre">(?L:...)</span></code> switches to locale depending
    matching, and <code class="docutils literal notranslate"><span class="pre">(?a:...)</span></code> switches to ASCII-only matching (default).
    This override is only in effect for the narrow inline group, and the
    original matching mode is restored outside of the group.</p>
    <div class="versionadded">
    <p><span class="versionmodified added">New in version 3.6.</span></p>
    </div>
    <div class="versionchanged">
    <p><span class="versionmodified changed">Changed in version 3.7: </span>The letters <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, <code class="docutils literal notranslate"><span class="pre">'L'</span></code> and <code class="docutils literal notranslate"><span class="pre">'u'</span></code> also can be used in a group.</p>
    </div>
    </dd>
    </dl>
    <dl id="index-17">
    <dt><code class="docutils literal notranslate"><span class="pre">(?P&lt;name&gt;...)</span></code></dt><dd><p>Similar to regular parentheses, but the substring matched by the group is
    accessible via the symbolic group name <em>name</em>.  Group names must be valid
    Python identifiers, and each group name must be defined only once within a
    regular expression.  A symbolic group is also a numbered group, just as if
    the group were not named.</p>
    <p>Named groups can be referenced in three contexts.  If the pattern is
    <code class="docutils literal notranslate"><span class="pre">(?P&lt;quote&gt;['"]).*?(?P=quote)</span></code> (i.e. matching a string quoted with either
    single or double quotes):</p>
    <table class="docutils align-default">
    <colgroup>
    <col style="width: 53%">
    <col style="width: 47%">
    </colgroup>
    <thead>
    <tr class="row-odd"><th class="head"><p>Context of reference to group “quote”</p></th>
    <th class="head"><p>Ways to reference it</p></th>
    </tr>
    </thead>
    <tbody>
    <tr class="row-even"><td><p>in the same pattern itself</p></td>
    <td><ul class="simple">
    <li><p><code class="docutils literal notranslate"><span class="pre">(?P=quote)</span></code> (as shown)</p></li>
    <li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
    </ul>
    </td>
    </tr>
    <tr class="row-odd"><td><p>when processing match object <em>m</em></p></td>
    <td><ul class="simple">
    <li><p><code class="docutils literal notranslate"><span class="pre">m.group('quote')</span></code></p></li>
    <li><p><code class="docutils literal notranslate"><span class="pre">m.end('quote')</span></code> (etc.)</p></li>
    </ul>
    </td>
    </tr>
    <tr class="row-even"><td><p>in a string passed to the <em>repl</em>
    argument of <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code></p></td>
    <td><ul class="simple">
    <li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;quote&gt;</span></code></p></li>
    <li><p><code class="docutils literal notranslate"><span class="pre">\g&lt;1&gt;</span></code></p></li>
    <li><p><code class="docutils literal notranslate"><span class="pre">\1</span></code></p></li>
    </ul>
    </td>
    </tr>
    </tbody>
    </table>
    </dd>
    </dl>
    <dl class="simple" id="index-18">
    <dt><code class="docutils literal notranslate"><span class="pre">(?P=name)</span></code></dt><dd><p>A backreference to a named group; it matches whatever text was matched by the
    earlier group named <em>name</em>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-19">
    <dt><code class="docutils literal notranslate"><span class="pre">(?#...)</span></code></dt><dd><p>A comment; the contents of the parentheses are simply ignored.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-20">
    <dt><code class="docutils literal notranslate"><span class="pre">(?=...)</span></code></dt><dd><p>Matches if <code class="docutils literal notranslate"><span class="pre">...</span></code> matches next, but doesn’t consume any of the string.  This is
    called a <em class="dfn">lookahead assertion</em>.  For example, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?=Asimov)</span></code> will match
    <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> only if it’s followed by <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-21">
    <dt><code class="docutils literal notranslate"><span class="pre">(?!...)</span></code></dt><dd><p>Matches if <code class="docutils literal notranslate"><span class="pre">...</span></code> doesn’t match next.  This is a <em class="dfn">negative lookahead assertion</em>.
    For example, <code class="docutils literal notranslate"><span class="pre">Isaac</span> <span class="pre">(?!Asimov)</span></code> will match <code class="docutils literal notranslate"><span class="pre">'Isaac</span> <span class="pre">'</span></code> only if it’s <em>not</em>
    followed by <code class="docutils literal notranslate"><span class="pre">'Asimov'</span></code>.</p>
    </dd>
    </dl>
    <dl id="index-22">
    <dt><code class="docutils literal notranslate"><span class="pre">(?&lt;=...)</span></code></dt><dd><p>Matches if the current position in the string is preceded by a match for <code class="docutils literal notranslate"><span class="pre">...</span></code>
    that ends at the current position.  This is called a <em class="dfn">positive lookbehind
    assertion</em>. <code class="docutils literal notranslate"><span class="pre">(?&lt;=abc)def</span></code> will find a match in <code class="docutils literal notranslate"><span class="pre">'abcdef'</span></code>, since the
    lookbehind will back up 3 characters and check if the contained pattern matches.
    The contained pattern must only match strings of some fixed length, meaning that
    <code class="docutils literal notranslate"><span class="pre">abc</span></code> or <code class="docutils literal notranslate"><span class="pre">a|b</span></code> are allowed, but <code class="docutils literal notranslate"><span class="pre">a*</span></code> and <code class="docutils literal notranslate"><span class="pre">a{{"{"}}3,4{{"}"}}</span></code> are not.  Note that
    patterns which start with positive lookbehind assertions will not match at the
    beginning of the string being searched; you will most likely want to use the
    <a class="reference internal" href="#re.search" title="re.search"><code class="xref py py-func docutils literal notranslate"><span class="pre">search()</span></code></a> function rather than the <a class="reference internal" href="#re.match" title="re.match"><code class="xref py py-func docutils literal notranslate"><span class="pre">match()</span></code></a> function:</p>
    <div class="doctest highlight-default notranslate" style="position: relative;"><div class="highlight"><span class="copybutton" title="Hide the prompts and output" style="cursor: pointer; position: absolute; top: 0px; right: 0px; border-color: rgb(170, 204, 153); border-style: solid; border-width: 1px; color: rgb(170, 204, 153); font-family: monospace; padding-left: 0.2em; padding-right: 0.2em; border-radius: 0px 3px 0px 0px;">&gt;&gt;&gt;</span><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">re</span>
    <span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">'(?&lt;=abc)def'</span><span class="p">,</span> <span class="s1">'abcdef'</span><span class="p">)</span>
    <span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="go">'def'</span>
    </pre></div>
    </div>
    <p>This example looks for a word following a hyphen:</p>
    <div class="doctest highlight-default notranslate" style="position: relative;"><div class="highlight"><span class="copybutton" title="Hide the prompts and output" style="cursor: pointer; position: absolute; top: 0px; right: 0px; border-color: rgb(170, 204, 153); border-style: solid; border-width: 1px; color: rgb(170, 204, 153); font-family: monospace; padding-left: 0.2em; padding-right: 0.2em; border-radius: 0px 3px 0px 0px;">&gt;&gt;&gt;</span><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">'(?&lt;=-)\w+'</span><span class="p">,</span> <span class="s1">'spam-egg'</span><span class="p">)</span>
    <span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="go">'egg'</span>
    </pre></div>
    </div>
    <div class="versionchanged">
    <p><span class="versionmodified changed">Changed in version 3.5: </span>Added support for group references of fixed length.</p>
    </div>
    </dd>
    </dl>
    <dl class="simple" id="index-23">
    <dt><code class="docutils literal notranslate"><span class="pre">(?&lt;!...)</span></code></dt><dd><p>Matches if the current position in the string is not preceded by a match for
    <code class="docutils literal notranslate"><span class="pre">...</span></code>.  This is called a <em class="dfn">negative lookbehind assertion</em>.  Similar to
    positive lookbehind assertions, the contained pattern must only match strings of
    some fixed length.  Patterns which start with negative lookbehind assertions may
    match at the beginning of the string being searched.</p>
    </dd>
    <dt><code class="docutils literal notranslate"><span class="pre">(?(id/name)yes-pattern|no-pattern)</span></code></dt><dd><p>Will try to match with <code class="docutils literal notranslate"><span class="pre">yes-pattern</span></code> if the group with given <em>id</em> or
    <em>name</em> exists, and with <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> if it doesn’t. <code class="docutils literal notranslate"><span class="pre">no-pattern</span></code> is
    optional and can be omitted. For example,
    <code class="docutils literal notranslate"><span class="pre">(&lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&gt;|$)</span></code> is a poor email matching pattern, which
    will match with <code class="docutils literal notranslate"><span class="pre">'&lt;user@host.com&gt;'</span></code> as well as <code class="docutils literal notranslate"><span class="pre">'user@host.com'</span></code>, but
    not with <code class="docutils literal notranslate"><span class="pre">'&lt;user@host.com'</span></code> nor <code class="docutils literal notranslate"><span class="pre">'user@host.com&gt;'</span></code>.</p>
    </dd>
    </dl>
    <p>The special sequences consist of <code class="docutils literal notranslate"><span class="pre">'\'</span></code> and a character from the list below.
    If the ordinary character is not an ASCII digit or an ASCII letter, then the
    resulting RE will match the second character.  For example, <code class="docutils literal notranslate"><span class="pre">\$</span></code> matches the
    character <code class="docutils literal notranslate"><span class="pre">'$'</span></code>.</p>
    <dl class="simple" id="index-24">
    <dt><code class="docutils literal notranslate"><span class="pre">\number</span></code></dt><dd><p>Matches the contents of the group of the same number.  Groups are numbered
    starting from 1.  For example, <code class="docutils literal notranslate"><span class="pre">(.+)</span> <span class="pre">\1</span></code> matches <code class="docutils literal notranslate"><span class="pre">'the</span> <span class="pre">the'</span></code> or <code class="docutils literal notranslate"><span class="pre">'55</span> <span class="pre">55'</span></code>,
    but not <code class="docutils literal notranslate"><span class="pre">'thethe'</span></code> (note the space after the group).  This special sequence
    can only be used to match one of the first 99 groups.  If the first digit of
    <em>number</em> is 0, or <em>number</em> is 3 octal digits long, it will not be interpreted as
    a group match, but as the character with octal value <em>number</em>. Inside the
    <code class="docutils literal notranslate"><span class="pre">'['</span></code> and <code class="docutils literal notranslate"><span class="pre">']'</span></code> of a character class, all numeric escapes are treated as
    characters.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-25">
    <dt><code class="docutils literal notranslate"><span class="pre">\A</span></code></dt><dd><p>Matches only at the start of the string.</p>
    </dd>
    </dl>
    <dl id="index-26">
    <dt><code class="docutils literal notranslate"><span class="pre">\b</span></code></dt><dd><p>Matches the empty string, but only at the beginning or end of a word.
    A word is defined as a sequence of word characters.  Note that formally,
    <code class="docutils literal notranslate"><span class="pre">\b</span></code> is defined as the boundary between a <code class="docutils literal notranslate"><span class="pre">\w</span></code> and a <code class="docutils literal notranslate"><span class="pre">\W</span></code> character
    (or vice versa), or between <code class="docutils literal notranslate"><span class="pre">\w</span></code> and the beginning/end of the string.
    This means that <code class="docutils literal notranslate"><span class="pre">r'\bfoo\b'</span></code> matches <code class="docutils literal notranslate"><span class="pre">'foo'</span></code>, <code class="docutils literal notranslate"><span class="pre">'foo.'</span></code>, <code class="docutils literal notranslate"><span class="pre">'(foo)'</span></code>,
    <code class="docutils literal notranslate"><span class="pre">'bar</span> <span class="pre">foo</span> <span class="pre">baz'</span></code> but not <code class="docutils literal notranslate"><span class="pre">'foobar'</span></code> or <code class="docutils literal notranslate"><span class="pre">'foo3'</span></code>.</p>
    <p>By default Unicode alphanumerics are the ones used in Unicode patterns, but
    this can be changed by using the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag.  Word boundaries are
    determined by the current locale if the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used.
    Inside a character range, <code class="docutils literal notranslate"><span class="pre">\b</span></code> represents the backspace character, for
    compatibility with Python’s string literals.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-27">
    <dt><code class="docutils literal notranslate"><span class="pre">\B</span></code></dt><dd><p>Matches the empty string, but only when it is <em>not</em> at the beginning or end
    of a word.  This means that <code class="docutils literal notranslate"><span class="pre">r'py\B'</span></code> matches <code class="docutils literal notranslate"><span class="pre">'python'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py3'</span></code>,
    <code class="docutils literal notranslate"><span class="pre">'py2'</span></code>, but not <code class="docutils literal notranslate"><span class="pre">'py'</span></code>, <code class="docutils literal notranslate"><span class="pre">'py.'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'py!'</span></code>.
    <code class="docutils literal notranslate"><span class="pre">\B</span></code> is just the opposite of <code class="docutils literal notranslate"><span class="pre">\b</span></code>, so word characters in Unicode
    patterns are Unicode alphanumerics or the underscore, although this can
    be changed by using the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag.  Word boundaries are
    determined by the current locale if the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is used.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-28">
    <dt><code class="docutils literal notranslate"><span class="pre">\d</span></code></dt><dd><dl class="simple">
    <dt>For Unicode (str) patterns:</dt><dd><p>Matches any Unicode decimal digit (that is, any character in
    Unicode character category [Nd]).  This includes <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>, and
    also many other digit characters.  If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is
    used only <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code> is matched.</p>
    </dd>
    <dt>For 8-bit (bytes) patterns:</dt><dd><p>Matches any decimal digit; this is equivalent to <code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>.</p>
    </dd>
    </dl>
    </dd>
    </dl>
    <dl class="simple" id="index-29">
    <dt><code class="docutils literal notranslate"><span class="pre">\D</span></code></dt><dd><p>Matches any character which is not a decimal digit. This is
    the opposite of <code class="docutils literal notranslate"><span class="pre">\d</span></code>. If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used this
    becomes the equivalent of <code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-30">
    <dt><code class="docutils literal notranslate"><span class="pre">\s</span></code></dt><dd><dl class="simple">
    <dt>For Unicode (str) patterns:</dt><dd><p>Matches Unicode whitespace characters (which includes
    <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>, and also many other characters, for example the
    non-breaking spaces mandated by typography rules in many
    languages). If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used, only
    <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code> is matched.</p>
    </dd>
    <dt>For 8-bit (bytes) patterns:</dt><dd><p>Matches characters considered whitespace in the ASCII character set;
    this is equivalent to <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
    </dd>
    </dl>
    </dd>
    </dl>
    <dl class="simple" id="index-31">
    <dt><code class="docutils literal notranslate"><span class="pre">\S</span></code></dt><dd><p>Matches any character which is not a whitespace character. This is
    the opposite of <code class="docutils literal notranslate"><span class="pre">\s</span></code>. If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used this
    becomes the equivalent of <code class="docutils literal notranslate"><span class="pre">[^</span> <span class="pre">\t\n\r\f\v]</span></code>.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-32">
    <dt><code class="docutils literal notranslate"><span class="pre">\w</span></code></dt><dd><dl class="simple">
    <dt>For Unicode (str) patterns:</dt><dd><p>Matches Unicode word characters; this includes most characters
    that can be part of a word in any language, as well as numbers and
    the underscore. If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used, only
    <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code> is matched.</p>
    </dd>
    <dt>For 8-bit (bytes) patterns:</dt><dd><p>Matches characters considered alphanumeric in the ASCII character set;
    this is equivalent to <code class="docutils literal notranslate"><span class="pre">[a-zA-Z0-9_]</span></code>.  If the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is
    used, matches characters considered alphanumeric in the current locale
    and the underscore.</p>
    </dd>
    </dl>
    </dd>
    </dl>
    <dl class="simple" id="index-33">
    <dt><code class="docutils literal notranslate"><span class="pre">\W</span></code></dt><dd><p>Matches any character which is not a word character. This is
    the opposite of <code class="docutils literal notranslate"><span class="pre">\w</span></code>. If the <a class="reference internal" href="#re.ASCII" title="re.ASCII"><code class="xref py py-const docutils literal notranslate"><span class="pre">ASCII</span></code></a> flag is used this
    becomes the equivalent of <code class="docutils literal notranslate"><span class="pre">[^a-zA-Z0-9_]</span></code>.  If the <a class="reference internal" href="#re.LOCALE" title="re.LOCALE"><code class="xref py py-const docutils literal notranslate"><span class="pre">LOCALE</span></code></a> flag is
    used, matches characters which are neither alphanumeric in the current locale
    nor the underscore.</p>
    </dd>
    </dl>
    <dl class="simple" id="index-34">
    <dt><code class="docutils literal notranslate"><span class="pre">\Z</span></code></dt><dd><p>Matches only at the end of the string.</p>
    </dd>
    </dl>
    <p id="index-35">Most of the standard escapes supported by Python string literals are also
    accepted by the regular expression parser:</p>
    <div class="highlight-python3 notranslate" style="position: relative;"><div class="highlight"><pre><span></span>\<span class="n">a</span>      \<span class="n">b</span>      \<span class="n">f</span>      \<span class="n">n</span>
    \<span class="n">N</span>      \<span class="n">r</span>      \<span class="n">t</span>      \<span class="n">u</span>
    \<span class="n">U</span>      \<span class="n">v</span>      \<span class="n">x</span>      \\
    </pre></div>
    </div>
    <p>(Note that <code class="docutils literal notranslate"><span class="pre">\b</span></code> is used to represent word boundaries, and means “backspace”
    only inside character classes.)</p>
    <p><code class="docutils literal notranslate"><span class="pre">'\u'</span></code>, <code class="docutils literal notranslate"><span class="pre">'\U'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'\N'</span></code> escape sequences are only recognized in Unicode
    patterns.  In bytes patterns they are errors.  Unknown escapes of ASCII
    letters are reserved for future use and treated as errors.</p>
    <p>Octal escapes are included in a limited form.  If the first digit is a 0, or if
    there are three octal digits, it is considered an octal escape. Otherwise, it is
    a group reference.  As for string literals, octal escapes are always at most
    three digits in length.</p>
    </div>